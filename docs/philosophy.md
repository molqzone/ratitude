# ratitude 哲学（v0.2）

> ⚠️ **破坏性改动声明（Breaking Change）**  
> 本文定义的是 `0.2.0` 破坏式重构路线。旧 CLI 与旧配置路径会被移除，不做长期双栈兼容。

## 0. 先回答 Linus 三问

1. 这是一个真实问题吗？

- 是。真实问题是配置分叉、协议漂移、入口重复导致的维护失控。

1. 有更简单的做法吗？

- 有。把“如何解析数据”收敛到运行时单一协议路径，删除并行控制面。

1. 会破坏什么？

- 会破坏旧命令、旧配置字段和旧 init-magic 心智模型；这是有意识的破坏式升级，不是兼容性回归。

---

## 1. 问题定义

当前风险不是功能不足，而是语义分叉：

- 解析语义散落在历史约定、配置和实现里。
- 控制入口并行导致行为漂移。
- 文档与代码容易失配，排障成本高。

---

## 2. 核心决策（冻结）

### D1. 单一事实源（SSOT）

- 唯一事实源：固件运行时下发的 schema 控制帧。
- `rat_gen.h` 由 `ratsync` 生成并参与固件构建。
- `rat.toml` 只负责运行时 wiring（数据源/输出/行为），不定义 payload 字段语义。

### D2. 运行模型（破坏式）

- 流程固定为 `ratsync -> build/flash -> ratd`。
- `ratd` 默认进入交互式 daemon（命令台 + 状态面板），运行时不触发 sync。
- 协议 ingest runtime 下沉到 `rat-core`，`ratd` 仅负责控制面编排。

### D3. 数据源策略

- 每次启动自动扫描候选 RTT 端点地址（基于 `last_selected_addr` + 默认端口探测）。
- `ratd` 不托管 backend 进程，只连接已存在端点。
- 后端类型不参与当前 source 选择模型，不承诺 openocd/pyocd/jlink 类型判定。
- 候选必须可见并可选。
- 选择结果持久化到 `rat.toml`。

### D4. Schema 协议策略

- runtime 启动后先进入 `WaitingSchema`。
- 通过控制帧 `HELLO -> SCHEMA_CHUNK -> SCHEMA_COMMIT` 装配 schema。
- schema hash 校验失败、超时、或协议格式错误时直接 fail-fast。
- `Ready` 前丢弃业务包，不做隐式补偿。

### D5. 输出策略

- 通过命令台动态启停 foxglove/jsonl。
- 输出控制从历史子命令迁移到运行时命令控制。

### D6. 升级策略（明确破坏性）

- 目标版本：`0.2.0`。
- 旧命令和旧配置直接报错，并提供迁移提示。
- 不保留长期兼容壳，避免维护分叉。

---

## 3. 边界条件（必须满足）

- schema 在 `schema_timeout` 窗口内未完成：启动直接失败。
- schema hash 不一致：直接失败。
- 配置项必须“可观察、可生效、可测试”。
- 文档与代码冲突时，以代码行为为准并立即回写文档。

---

## 4. 非目标（明确不做）

- 首版不引入复杂 TUI 框架。
- `.ratignore` 首版不支持 `!` 反选语法。
- 不引入第二套 payload 解析配置体系。
- 不做长期双轨兼容。

---

## 5. 命令台最小集合（首版固定）

- `$help`
- `$status`
- `$source list`
- `$source use <index>`
- `$foxglove on|off`
- `$jsonl on|off [path]`
- `/packet/<struct>/<field>`

---

## 6. 工程判定标准（Taste Gate）

每个改动都必须回答：

- 是否减少了特殊分支？
- 是否减少了状态与入口数量？
- 是否让失败更早、更明确？
- 是否避免“看起来可配但无效”的接口？

任一答案为“否”，默认不合并。

---

## 7. 验收口径

- CLI、配置、文档三者一致。
- 自动扫描、选择、schema 就绪、输出启停链路可复现。
- 旧命令和旧配置被明确拒绝并给出迁移提示。
- 关键行为具备测试覆盖（配置校验、候选刷新、命令解析、schema 协议校验、unknown packet 监控）。
