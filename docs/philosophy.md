# ratitude 哲学（v0.2）

> ⚠️ **破坏性改动声明（Breaking Change）**  
> 本文定义的是 `0.2.0` 破坏式重构路线。旧 CLI 与旧配置路径会被移除，不做长期双栈兼容。

## 0. 先回答 Linus 三问

1. 这是一个真实问题吗？

- 是。真实问题是配置分叉、协议漂移、入口重复导致的维护失控。

1. 有更简单的做法吗？

- 有。把“如何解析数据”收敛到单一事实源，删除并行控制面。

1. 会破坏什么？

- 会破坏旧命令与旧配置结构；这是有意识的破坏式升级，不是兼容性回归。

---

## 1. 问题定义

当前风险不是功能不足，而是语义分叉：

- 解析语义散落在历史约定、配置和实现里。
- 控制入口并行导致行为漂移。
- 文档与代码容易失配，排障成本高。

---

## 2. 核心决策（冻结）

### D1. 单一事实源（SSOT）

- 唯一事实源：C/C++ 源码中的 `@rat` 声明。
- `rat_gen.toml` / `rat_gen.h` 是编译产物，不是手工配置入口。
- `rat.toml` 只负责运行时 wiring（数据源/输出/行为），不定义 payload 字段语义。

### D2. 运行模型（破坏式）

- `rttd` 默认进入交互式 daemon（命令台 + 状态面板）。
- 删除所有外部子命令，统一为单入口 daemon 控制面。

### D3. 数据源策略

- 每次启动自动扫描候选 RTT 端点地址（基于 `last_selected_addr` + 默认端口探测）。
- `rttd` 不托管 backend 进程，只连接已存在端点。
- 后端类型不参与当前 source 选择模型，不承诺 openocd/pyocd/jlink 类型判定。
- 候选必须可见并可选。
- 选择结果持久化到 `rat.toml`。

### D4. 同步策略

- 启动自动 `sync`（可关闭）。
- init/reset 事件触发“防抖 + 单飞 sync”。
- 仅保留命令台 `$sync` 手动触发，不保留外部同步命令。
- `sync` 失败必须 fail-fast，不允许静默降级。

### D5. 输出策略

- 通过命令台动态启停 foxglove/jsonl。
- 输出控制从子命令迁移到运行时命令控制。

### D6. 升级策略（明确破坏性）

- 目标版本：`0.2.0`。
- 旧命令和旧配置直接报错，并提供迁移提示。
- 不保留长期兼容壳，避免维护分叉。

---

## 3. 边界条件（必须满足）

- `rat_gen.toml` 缺失或空包：启动直接失败。
- init magic 指纹不一致：直接失败。
- 配置项必须“可观察、可生效、可测试”。
- 文档与代码冲突时，以代码行为为准并立即回写文档。

---

## 4. 非目标（明确不做）

- 首版不引入复杂 TUI 框架。
- `.rttdignore` 首版不支持 `!` 反选语法。
- 不引入第二套 payload 解析配置体系。
- 不做长期双轨兼容。

---

## 5. 命令台最小集合（首版固定）

- `$help`
- `$status`
- `$source list`
- `$source use <index>`
- `$sync`
- `$foxglove on|off`
- `$jsonl on|off [path]`
- `/packet/<struct>/<field>`

---

## 6. 工程判定标准（Taste Gate）

每个改动都必须回答：

- 是否减少了特殊分支？
- 是否减少了状态与入口数量？
- 是否让失败更早、更明确？
- 是否避免“看起来可配但无效”的接口？

任一答案为“否”，默认不合并。

---

## 7. 验收口径

- CLI、配置、文档三者一致。
- 自动扫描、选择、同步、输出启停链路可复现。
- 旧命令和旧配置被明确拒绝并给出迁移提示。
- 关键行为具备测试覆盖（配置校验、ignore、命令解析、sync 防抖、指纹校验）。
