use std::collections::HashMap;
use std::fs;
use std::path::Path;

use crate::generated::GeneratedConfig;
use crate::schema::build_runtime_schema_toml;
use crate::SyncError;

pub(crate) fn write_generated_header(
    path: &Path,
    generated: &GeneratedConfig,
) -> Result<(), SyncError> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).map_err(|source| SyncError::WriteHeader {
            path: path.to_path_buf(),
            source,
        })?;
    }

    let mut out = String::new();
    out.push_str("#ifndef RAT_GEN_H\n");
    out.push_str("#define RAT_GEN_H\n\n");
    out.push_str("#include <stdint.h>\n\n");
    out.push_str("/* This file is generated by rat-sync. */\n");
    out.push_str(&format!(
        "#define RAT_GEN_PACKET_COUNT {}u\n",
        generated.packets.len()
    ));
    let schema_toml = build_runtime_schema_toml(generated);
    let schema_bytes = schema_toml.as_bytes();
    let schema_hash = parse_schema_hash(&generated.meta.schema_hash)?;
    out.push_str(&format!(
        "#define RAT_GEN_SCHEMA_HASH 0x{:016X}ULL\n",
        schema_hash
    ));
    out.push_str(&format!(
        "#define RAT_GEN_SCHEMA_LEN {}u\n",
        schema_bytes.len()
    ));
    emit_schema_bytes(&mut out, schema_bytes);
    out.push('\n');

    let mut name_counts: HashMap<String, usize> = HashMap::new();
    for packet in &generated.packets {
        let base = macroize_struct_name(&packet.struct_name);
        let count = name_counts
            .entry(base.clone())
            .and_modify(|value| *value += 1)
            .or_insert(1);
        let macro_name = if *count == 1 {
            format!("RAT_ID_{base}")
        } else {
            format!("RAT_ID_{}_{}", base, count)
        };
        out.push_str(&format!("#define {macro_name} 0x{:02X}u\n", packet.id));
    }

    out.push_str("\n#endif  /* RAT_GEN_H */\n");

    fs::write(path, out).map_err(|source| SyncError::WriteHeader {
        path: path.to_path_buf(),
        source,
    })
}

pub(crate) fn macroize_struct_name(value: &str) -> String {
    let mut out = String::new();
    for ch in value.chars() {
        if ch.is_ascii_alphanumeric() {
            out.push(ch.to_ascii_uppercase());
        } else {
            out.push('_');
        }
    }

    while out.contains("__") {
        out = out.replace("__", "_");
    }

    out.trim_matches('_').to_string()
}

fn emit_schema_bytes(out: &mut String, schema_bytes: &[u8]) {
    if schema_bytes.is_empty() {
        out.push_str("static const uint8_t rat_gen_schema_bytes[1] = { 0x00u };\n");
        out.push_str("#define RAT_GEN_SCHEMA_BYTES rat_gen_schema_bytes\n");
        return;
    }

    out.push_str("static const uint8_t rat_gen_schema_bytes[RAT_GEN_SCHEMA_LEN] = {\n");
    for (index, byte) in schema_bytes.iter().enumerate() {
        if index % 12 == 0 {
            out.push_str("  ");
        }
        out.push_str(&format!("0x{:02X}u", byte));
        if index + 1 != schema_bytes.len() {
            out.push_str(", ");
        }
        if index % 12 == 11 || index + 1 == schema_bytes.len() {
            out.push('\n');
        }
    }
    out.push_str("};\n");
    out.push_str("#define RAT_GEN_SCHEMA_BYTES rat_gen_schema_bytes\n");
}

fn parse_schema_hash(raw: &str) -> Result<u64, SyncError> {
    let trimmed = raw.trim();
    let hex = trimmed
        .strip_prefix("0x")
        .or_else(|| trimmed.strip_prefix("0X"))
        .unwrap_or(trimmed);
    u64::from_str_radix(hex, 16).map_err(|_| {
        SyncError::Validation(format!(
            "invalid schema hash in generated metadata: {}",
            raw
        ))
    })
}

#[cfg(test)]
mod tests {
    use std::fs;

    use rat_config::{FieldDef, PacketType};

    use super::*;
    use crate::generated::{GeneratedMeta, GeneratedPacketDef};

    fn sample_generated() -> GeneratedConfig {
        let packets = vec![GeneratedPacketDef {
            id: 0x21,
            signature_hash: "0x2".to_string(),
            struct_name: "DemoPacket".to_string(),
            packet_type: PacketType::Plot,
            packed: true,
            byte_size: 4,
            source: "src/main.c".to_string(),
            fields: vec![FieldDef {
                name: "value".to_string(),
                c_type: "uint32_t".to_string(),
                offset: 0,
                size: 4,
            }],
        }];
        let schema_hash = crate::schema::compute_runtime_schema_hash_from_packets(&packets);

        GeneratedConfig {
            meta: GeneratedMeta {
                project: "demo".to_string(),
                schema_hash: format!("0x{schema_hash:016X}"),
            },
            packets,
        }
    }

    #[test]
    fn runtime_schema_toml_contains_packet_and_field_layout() {
        let schema = build_runtime_schema_toml(&sample_generated());
        assert!(schema.contains("[[packets]]"));
        assert!(schema.contains("id = 33"));
        assert!(schema.contains("struct_name = \"DemoPacket\""));
        assert!(schema.contains("type = \"plot\""));
        assert!(schema.contains("[[packets.fields]]"));
        assert!(schema.contains("name = \"value\""));
    }

    #[test]
    fn write_generated_header_includes_schema_macros() {
        let dir =
            std::env::temp_dir().join(format!("rat_sync_header_schema_{}", std::process::id()));
        let _ = fs::remove_dir_all(&dir);
        fs::create_dir_all(&dir).expect("mkdir");
        let path = dir.join("rat_gen.h");

        write_generated_header(&path, &sample_generated()).expect("write header");
        let raw = fs::read_to_string(&path).expect("read header");

        assert!(raw.contains("#define RAT_GEN_SCHEMA_HASH 0x"));
        assert!(raw.contains("#define RAT_GEN_SCHEMA_LEN "));
        assert!(raw.contains("static const uint8_t rat_gen_schema_bytes"));
        assert!(raw.contains("#define RAT_GEN_SCHEMA_BYTES rat_gen_schema_bytes"));

        let _ = fs::remove_file(path);
        let _ = fs::remove_dir_all(dir);
    }

    #[test]
    fn write_generated_header_fails_on_invalid_schema_hash() {
        let dir = std::env::temp_dir().join(format!(
            "rat_sync_header_schema_invalid_{}",
            std::process::id()
        ));
        let _ = fs::remove_dir_all(&dir);
        fs::create_dir_all(&dir).expect("mkdir");
        let path = dir.join("rat_gen.h");

        let mut generated = sample_generated();
        generated.meta.schema_hash = "not-a-hex-hash".to_string();

        let err = write_generated_header(&path, &generated).expect_err("must fail");
        assert!(err
            .to_string()
            .contains("invalid schema hash in generated metadata"));

        let _ = fs::remove_file(path);
        let _ = fs::remove_dir_all(dir);
    }
}
