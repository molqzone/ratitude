use std::collections::HashMap;
use std::fs;
use std::path::Path;

use rat_config::PacketDef;
use serde::Deserialize;

use crate::generated::GeneratedConfig;
use crate::schema::build_runtime_schema_toml;
use crate::SyncError;

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct RuntimeSchemaToml {
    packets: Vec<PacketDef>,
}

pub(crate) fn write_generated_header(
    path: &Path,
    generated: &GeneratedConfig,
) -> Result<(), SyncError> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).map_err(|source| SyncError::WriteHeader {
            path: path.to_path_buf(),
            source,
        })?;
    }

    let mut out = String::new();
    out.push_str("#ifndef RAT_GEN_H\n");
    out.push_str("#define RAT_GEN_H\n\n");
    out.push_str("#include <stdint.h>\n\n");
    out.push_str("/* This file is generated by rat-sync. */\n");
    out.push_str(&format!(
        "#define RAT_GEN_PACKET_COUNT {}u\n",
        generated.packets.len()
    ));
    let schema_toml = build_runtime_schema_toml(generated);
    let schema_bytes = schema_toml.as_bytes();
    let schema_hash = parse_schema_hash(&generated.meta.schema_hash)?;
    out.push_str(&format!(
        "#define RAT_GEN_SCHEMA_HASH 0x{:016X}ULL\n",
        schema_hash
    ));
    out.push_str(&format!(
        "#define RAT_GEN_SCHEMA_LEN {}u\n",
        schema_bytes.len()
    ));
    emit_schema_bytes(&mut out, schema_bytes);
    out.push('\n');

    let mut name_counts: HashMap<String, usize> = HashMap::new();
    for packet in &generated.packets {
        let base = macroize_struct_name(&packet.struct_name);
        let count = name_counts
            .entry(base.clone())
            .and_modify(|value| *value += 1)
            .or_insert(1);
        let macro_name = if *count == 1 {
            format!("RAT_ID_{base}")
        } else {
            format!("RAT_ID_{}_{}", base, count)
        };
        out.push_str(&format!("#define {macro_name} 0x{:02X}u\n", packet.id));
    }

    out.push_str("\n#endif  /* RAT_GEN_H */\n");

    fs::write(path, out).map_err(|source| SyncError::WriteHeader {
        path: path.to_path_buf(),
        source,
    })
}

pub(crate) fn read_generated_header_packets(path: &Path) -> Result<Vec<PacketDef>, SyncError> {
    let raw = match fs::read_to_string(path) {
        Ok(raw) => raw,
        Err(err) if err.kind() == std::io::ErrorKind::NotFound => return Ok(Vec::new()),
        Err(source) => {
            return Err(SyncError::ReadGeneratedHeader {
                path: path.to_path_buf(),
                source,
            });
        }
    };

    parse_generated_header_packets(&raw, path)
}

pub(crate) fn macroize_struct_name(value: &str) -> String {
    let mut out = String::with_capacity(value.len());
    let mut prev_separator = true;
    for ch in value.chars() {
        if ch.is_ascii_alphanumeric() {
            out.push(ch.to_ascii_uppercase());
            prev_separator = false;
        } else if !prev_separator {
            out.push('_');
            prev_separator = true;
        }
    }
    if out.ends_with('_') {
        out.pop();
    }
    out
}

fn emit_schema_bytes(out: &mut String, schema_bytes: &[u8]) {
    if schema_bytes.is_empty() {
        out.push_str("static const uint8_t rat_gen_schema_bytes[1] = { 0x00u };\n");
        out.push_str("#define RAT_GEN_SCHEMA_BYTES rat_gen_schema_bytes\n");
        return;
    }

    out.push_str("static const uint8_t rat_gen_schema_bytes[RAT_GEN_SCHEMA_LEN] = {\n");
    for (index, byte) in schema_bytes.iter().enumerate() {
        if index % 12 == 0 {
            out.push_str("  ");
        }
        out.push_str(&format!("0x{:02X}u", byte));
        if index + 1 != schema_bytes.len() {
            out.push_str(", ");
        }
        if index % 12 == 11 || index + 1 == schema_bytes.len() {
            out.push('\n');
        }
    }
    out.push_str("};\n");
    out.push_str("#define RAT_GEN_SCHEMA_BYTES rat_gen_schema_bytes\n");
}

fn parse_schema_hash(raw: &str) -> Result<u64, SyncError> {
    let trimmed = raw.trim();
    let hex = trimmed
        .strip_prefix("0x")
        .or_else(|| trimmed.strip_prefix("0X"))
        .unwrap_or(trimmed);
    u64::from_str_radix(hex, 16).map_err(|_| {
        SyncError::Validation(format!(
            "invalid schema hash in generated metadata: {}",
            raw
        ))
    })
}

fn parse_generated_header_packets(raw: &str, path: &Path) -> Result<Vec<PacketDef>, SyncError> {
    let schema_bytes = parse_schema_bytes_from_header(raw).ok_or_else(|| {
        SyncError::Validation(format!(
            "generated header {} is incompatible (missing rat_gen_schema_bytes); regenerate it with the current ratsync",
            path.display()
        ))
    })?;
    let schema_raw = String::from_utf8(schema_bytes).map_err(|err| {
        SyncError::Validation(format!(
            "generated header {} has invalid utf8 schema bytes ({err})",
            path.display()
        ))
    })?;
    let schema = schema_raw.trim_end_matches('\0').trim();
    if schema.is_empty() {
        return Ok(Vec::new());
    }
    let parsed: RuntimeSchemaToml = toml::from_str(schema).map_err(|err| {
        SyncError::Validation(format!(
            "generated header {} has invalid runtime schema ({err})",
            path.display()
        ))
    })?;
    Ok(parsed.packets)
}

fn parse_schema_bytes_from_header(raw: &str) -> Option<Vec<u8>> {
    const SCHEMA_BYTES_DECL: &str = "static const uint8_t rat_gen_schema_bytes";

    let decl_start = raw.find(SCHEMA_BYTES_DECL)?;
    let tail = &raw[decl_start + SCHEMA_BYTES_DECL.len()..];
    let body_start = tail.find('{')?;
    let body_tail = &tail[body_start + 1..];
    let body_end = body_tail.find("};")?;
    let body = &body_tail[..body_end];

    let mut bytes = Vec::new();
    for token in body.split(|ch: char| ch == ',' || ch.is_ascii_whitespace()) {
        let token = token.trim();
        if token.is_empty() {
            continue;
        }
        let hex = token
            .strip_prefix("0x")
            .or_else(|| token.strip_prefix("0X"))?
            .trim_end_matches(['u', 'U']);
        let value = u8::from_str_radix(hex, 16).ok()?;
        bytes.push(value);
    }
    if bytes.is_empty() {
        return None;
    }
    Some(bytes)
}

#[cfg(test)]
mod tests {
    use std::fs;

    use rat_config::{FieldDef, PacketDef, PacketType};

    use super::*;
    use crate::generated::GeneratedMeta;

    fn sample_generated() -> GeneratedConfig {
        let packets = vec![PacketDef {
            id: 0x21,
            struct_name: "DemoPacket".to_string(),
            packet_type: PacketType::Plot,
            packed: true,
            byte_size: 4,
            source: "src/main.c".to_string(),
            fields: vec![FieldDef {
                name: "value".to_string(),
                c_type: "uint32_t".to_string(),
                offset: 0,
                size: 4,
            }],
        }];
        let schema_hash = crate::schema::compute_runtime_schema_hash_from_packets(&packets);

        GeneratedConfig {
            meta: GeneratedMeta {
                project: "demo".to_string(),
                schema_hash: format!("0x{schema_hash:016X}"),
            },
            packets,
        }
    }

    #[test]
    fn runtime_schema_toml_contains_packet_and_field_layout() {
        let schema = build_runtime_schema_toml(&sample_generated());
        assert!(schema.contains("[[packets]]"));
        assert!(schema.contains("id = 33"));
        assert!(schema.contains("struct_name = \"DemoPacket\""));
        assert!(schema.contains("type = \"plot\""));
        assert!(schema.contains("[[packets.fields]]"));
        assert!(schema.contains("name = \"value\""));
    }

    #[test]
    fn write_generated_header_includes_schema_macros() {
        let dir =
            std::env::temp_dir().join(format!("rat_sync_header_schema_{}", std::process::id()));
        let _ = fs::remove_dir_all(&dir);
        fs::create_dir_all(&dir).expect("mkdir");
        let path = dir.join("rat_gen.h");

        write_generated_header(&path, &sample_generated()).expect("write header");
        let raw = fs::read_to_string(&path).expect("read header");

        assert!(raw.contains("#define RAT_GEN_SCHEMA_HASH 0x"));
        assert!(raw.contains("#define RAT_GEN_SCHEMA_LEN "));
        assert!(raw.contains("static const uint8_t rat_gen_schema_bytes"));
        assert!(raw.contains("#define RAT_GEN_SCHEMA_BYTES rat_gen_schema_bytes"));

        let _ = fs::remove_file(path);
        let _ = fs::remove_dir_all(dir);
    }

    #[test]
    fn write_generated_header_fails_on_invalid_schema_hash() {
        let dir = std::env::temp_dir().join(format!(
            "rat_sync_header_schema_invalid_{}",
            std::process::id()
        ));
        let _ = fs::remove_dir_all(&dir);
        fs::create_dir_all(&dir).expect("mkdir");
        let path = dir.join("rat_gen.h");

        let mut generated = sample_generated();
        generated.meta.schema_hash = "not-a-hex-hash".to_string();

        let err = write_generated_header(&path, &generated).expect_err("must fail");
        assert!(err
            .to_string()
            .contains("invalid schema hash in generated metadata"));

        let _ = fs::remove_file(path);
        let _ = fs::remove_dir_all(dir);
    }

    #[test]
    fn macroize_struct_name_collapses_non_alnum_runs() {
        assert_eq!(macroize_struct_name("DemoPacket"), "DEMOPACKET");
        assert_eq!(macroize_struct_name("Demo__Packet"), "DEMO_PACKET");
        assert_eq!(macroize_struct_name("  __Demo---Packet__  "), "DEMO_PACKET");
        assert_eq!(macroize_struct_name("__"), "");
    }

    #[test]
    fn read_generated_header_packets_round_trips_schema() {
        let dir = std::env::temp_dir().join(format!(
            "rat_sync_header_schema_roundtrip_{}",
            std::process::id()
        ));
        let _ = fs::remove_dir_all(&dir);
        fs::create_dir_all(&dir).expect("mkdir");
        let path = dir.join("rat_gen.h");
        let generated = sample_generated();

        write_generated_header(&path, &generated).expect("write header");
        let packets = read_generated_header_packets(&path).expect("read header packets");
        let expected = generated
            .packets
            .iter()
            .cloned()
            .map(|mut packet| {
                packet.source.clear();
                packet
            })
            .collect::<Vec<_>>();

        assert_eq!(packets, expected);

        let _ = fs::remove_file(path);
        let _ = fs::remove_dir_all(dir);
    }

    #[test]
    fn read_generated_header_packets_rejects_legacy_header_without_schema_bytes() {
        let dir = std::env::temp_dir().join(format!(
            "rat_sync_header_legacy_reject_{}",
            std::process::id()
        ));
        let _ = fs::remove_dir_all(&dir);
        fs::create_dir_all(&dir).expect("mkdir");
        let path = dir.join("rat_gen.h");

        let legacy = r#"
#ifndef RAT_GEN_H
#define RAT_GEN_H
/* legacy style header without embedded schema bytes */
#define RAT_GEN_SCHEMA_HASH 0x6DC228D8526C7443ULL
#define RAT_GEN_PACKET_COUNT 1u
#define RAT_ID_DEMOPACKET 0x21u
#endif
"#;
        fs::write(&path, legacy).expect("write legacy header");

        let err = read_generated_header_packets(&path).expect_err("legacy header should fail");
        let msg = err.to_string();
        assert!(msg.contains("incompatible"));
        assert!(msg.contains("rat_gen_schema_bytes"));

        let _ = fs::remove_file(path);
        let _ = fs::remove_dir_all(dir);
    }
}
